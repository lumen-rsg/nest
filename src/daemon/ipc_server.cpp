#include "ipc_server.hpp"
#include "router.hpp"
#include "transfer_manager.hpp"
#include <iostream>
#include <print>
#include <chrono>

namespace nest {

static std::string to_hex(const std::vector<uint8_t>& data) {
    std::string s;
    for(auto b : data) s += std::format("{:02x}", b);
    return s;
}

IPCServer::IPCServer() {}

IPCServer::~IPCServer() { stop(); }

void IPCServer::start() {
    running_ = true;
    thread_ = std::jthread([this] { loop(); });
}

void IPCServer::stop() {
    running_ = false;
    ctx_.shutdown();
}

void IPCServer::set_services(Router* router, TransferManager* transfers) {
    router_ = router;
    transfers_ = transfers;
}

void IPCServer::set_identity(const std::string& username, const std::string& pubkey_hex) {
    my_username_ = username;
    my_pubkey_ = pubkey_hex;
}

void IPCServer::broadcast_event(const std::string& type, const json& payload) {
    json j;
    j["type"] = "event";
    j["event"] = type;
    j["payload"] = payload;

    std::string serialized = j.dump(); // dump() can throw on invalid UTF-8
    {
        std::lock_guard lock(queue_mutex_);
        event_queue_.push(serialized);
    }
}

void IPCServer::loop() {
    try {
        zmq::socket_t socket(ctx_, zmq::socket_type::router);
        socket.bind("tcp://127.0.0.1:9002");
        std::println("[IPC] Server listening (ROUTER) on tcp://127.0.0.1:9002");

        while (running_) {
            zmq::pollitem_t items[] = { { static_cast<void*>(socket), 0, ZMQ_POLLIN, 0 } };
            zmq::poll(items, 1, std::chrono::milliseconds(20));

            // 1. Read Incoming (Robust Multipart)
            if (items[0].revents & ZMQ_POLLIN) {
                std::vector<zmq::message_t> frames;
                while (true) {
                    zmq::message_t& frame = frames.emplace_back();
                    if (!socket.recv(frame, zmq::recv_flags::none)) { frames.pop_back(); break; }
                    if (!socket.get(zmq::sockopt::rcvmore)) break;
                }

                if (frames.size() >= 2) {
                    const auto& id_frame = frames[0];
                    last_client_id_.assign(static_cast<const char*>(id_frame.data()), id_frame.size());

                    const auto& payload_frame = frames.back();
                    std::string payload_str(static_cast<const char*>(payload_frame.data()), payload_frame.size());

                    try {
                        auto j = json::parse(payload_str);
                        if (j.contains("command")) {
                            handle_command(j);
                        }
                    } catch (const std::exception& e) {
                        std::println(stderr, "[IPC] Error processing command: {}", e.what());
                    }
                }
            }

            // 2. Write Outgoing
            std::queue<std::string> outgoing;
            {
                std::lock_guard lock(queue_mutex_);
                outgoing.swap(event_queue_);
            }

            if (!last_client_id_.empty() && !outgoing.empty()) {
                while (!outgoing.empty()) {
                    std::string s = outgoing.front();
                    outgoing.pop();
                    try {
                        socket.send(zmq::buffer(last_client_id_), zmq::send_flags::sndmore);
                        socket.send(zmq::buffer(s), zmq::send_flags::dontwait);
                    } catch (...) {}
                }
            }
        }
    } catch (...) {}
}

void IPCServer::handle_command(const json& j) {
    std::string cmd = j["command"];

    if (cmd != "get_status") {
        std::println("[IPC] Processing: {}", cmd);
    }

    if (cmd == "get_status") {
        json info;
        if (router_) info["status"] = "ready";
        else info["status"] = on_get_status ? on_get_status() : "locked";
        info["username"] = my_username_;
        broadcast_event("status", info);
    }
    else if (cmd == "unlock") {
        std::string pass = j["payload"].value("password", "");
        if (on_unlock && !pass.empty()) on_unlock(pass);
    }
    else if (cmd == "setup") {
        std::string user = j["payload"].value("username", "");
        std::string pass = j["payload"].value("password", "");
        std::string ip   = j["payload"].value("server_ip", "");
        std::string avatar = j["payload"].value("avatar", "");
        std::string bio    = j["payload"].value("bio", "");
        if (on_setup) on_setup(user, pass, ip, avatar, bio);
    }
    else if (router_ && transfers_) {
        // --- Authenticated Commands ---
        const auto& p = j["payload"];

        if (cmd == "send_text") {
            std::string target = p["target"];
            std::string text = p["text"];

            // New Fields from Client
            std::string uuid = p.value("uuid", "");         // Generated by Flutter
            std::string reply_to = p.value("reply_to", ""); // Optional parent ID
            std::string local_id = p.value("local_id", ""); // For UI tracking

            if (target.starts_with("@")) target.erase(0, 1);

            auto remote = router_->lookup_user(target);
            if (remote) {
                // 1. Send to Network (Target, Text, UUID, ReplyTo)
                bool success = router_->send_text(*remote, text, uuid, reply_to);

                if (success) {
                    // 2. Save to DB (Peer, Text, IsMine, UUID, ReplyTo)
                    router_->db().save_message(
                        to_hex(remote->id_key),
                        text,
                        true,
                        uuid,
                        reply_to
                    );

                    // 3. ACK
                    if (!local_id.empty()) {
                        json ack; ack["local_id"] = local_id; ack["status"] = "sent";
                        broadcast_event("message_ack", ack);
                    }
                } else {
                    if (!local_id.empty()) {
                        json ack; ack["local_id"] = local_id; ack["status"] = "failed";
                        broadcast_event("message_ack", ack);
                    }
                }
            } else {
                json err; err["msg"] = "User @" + target + " not found.";
                broadcast_event("error", err);
            }
        }
        else if (cmd == "edit_msg") {
            std::string target = p["target"];
            std::string uuid = p["uuid"];
            std::string new_text = p["text"];
            if (target.starts_with("@")) target.erase(0, 1);

            auto remote = router_->lookup_user(target);
            if (remote) {
                // Send EDIT payload
                venom::Payload p_out;
                p_out.set_type(venom::Payload::EDIT);
                p_out.set_related_uuid(uuid);
                p_out.set_body(new_text);
                router_->send_payload(*remote, p_out);

                // Update local DB
                router_->db().edit_message(uuid, new_text);
            }
        }
        else if (cmd == "delete_msg") {
            std::string target = p["target"];
            std::string uuid = p["uuid"];
            if (target.starts_with("@")) target.erase(0, 1);

            auto remote = router_->lookup_user(target);
            if (remote) {
                // Send DELETE payload
                venom::Payload p_out;
                p_out.set_type(venom::Payload::DELETE);
                p_out.set_related_uuid(uuid);
                router_->send_payload(*remote, p_out);

                // Update local DB
                router_->db().delete_message(uuid);
            }
        }
        else if (cmd == "upload_file") {
            std::string target = p["target"];
            std::string path = p["filepath"];
            std::string caption = p.value("caption", ""); // NEW

            if (target.starts_with("@")) target.erase(0, 1);

            auto remote = router_->lookup_user(target);
            if (remote) {
                // Pass caption to TransferManager
                transfers_->queue_upload(path, *remote, caption);
            }
        }
        else if (cmd == "get_self") {
            json info;
            info["username"] = my_username_;
            info["pubkey"] = my_pubkey_;
            broadcast_event("ready", info);
        }
        else if (cmd == "add_contact") {
            std::string username = p["username"];
            if (username.starts_with("@")) username.erase(0, 1);

            auto remote = router_->lookup_user(username);
            if (remote) {
                router_->save_contact(remote->username, to_hex(remote->id_key));
                json evt; evt["username"] = remote->username;
                broadcast_event("contact_added", evt);
            } else {
                json err; err["msg"] = "User not found";
                broadcast_event("error", err);
            }
        }
        else if (cmd == "sync_request") {
            std::println("[IPC] Sync requested. Exporting DB...");
            try {
                json payload;
                payload["contacts"] = router_->get_all_chats();
                broadcast_event("sync_response", payload);
                std::println("[IPC] Sync data sent.");
            } catch (const std::exception& e) {
                std::println(stderr, "[IPC] Sync Failed: {}", e.what());
            }
        }
    }
    else {
        if (cmd != "get_status") {
            json err; err["msg"] = "Daemon Locked";
            broadcast_event("error", err);
        }
    }
}

} // namespace nest